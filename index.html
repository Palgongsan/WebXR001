<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>CERAGEM V11 WebXR Demo</title>
    <meta name="description" content="CERAGEM V11 ì œí’ˆì„ WebXR ê¸°ë°˜ AR í™˜ê²½ì—ì„œ ì²´í—˜í•˜ë©° ëª¨ë“œ, ì¬ì§ˆ, íšŒì „ì„ ì œì–´í•  ìˆ˜ ìˆëŠ” í”„ë¡œí† íƒ€ì…">
    <!-- í•œêµ­ì–´ ì£¼ì„: CORS ì´ìŠˆ ë°©ì§€ë¥¼ ìœ„í•´ ë¡œì»¬ì— ì €ì¥í•œ model-viewer ëª¨ë“ˆ ì‚¬ìš© -->
    <script type="module" src="./libs/model-viewer.min.js"></script>
    <style>
      :root {
        color-scheme: light;
        --bg-base: #f7f8fa;
        --surface: #ffffff;
        --border: #d8dbe3;
        --text-strong: #1d1f24;
        --text-muted: #5b6578;
        --accent: #2f54eb;
        --accent-soft: rgba(47, 84, 235, 0.1);
        --danger: #c92c2c;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Pretendard", "Noto Sans KR", "Segoe UI", sans-serif;
        background: var(--bg-base);
        color: var(--text-strong);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        padding: clamp(16px, 4vw, 40px);
      }

      main {
        width: min(1280px, 100%);
        display: grid;
        gap: clamp(16px, 3vw, 28px);
      }

      header {
        padding: 4px 0;
      }

      header h1 {
        margin: 0;
        font-size: clamp(24px, 3vw, 32px);
        font-weight: 600;
        letter-spacing: -0.01em;
      }

      model-viewer {
        width: 100%;
        aspect-ratio: 4 / 3;
        min-height: clamp(420px, 60vh, 720px);
        border-radius: 24px;
        background: var(--surface);
        border: 1px solid var(--border);
        --poster-color: #eef0f6;
        --progress-bar-height: 4px;
        --progress-bar-color: rgba(47, 84, 235, 0.7);
        position: relative;
        --ar-button-display: block;
      }

      #ar-start {
        position: absolute;
        bottom: clamp(12px, 2vw, 20px);
        right: 20px;
        padding: 0;
        border: none;
        background: transparent;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        cursor: pointer;
        transform: none;
      }

      #ar-start[disabled] {
        opacity: 0.45;
        cursor: not-allowed;
      }

      #ar-start img {
        display: block;
        width: clamp(50px, 13.5vw, 50px);
        height: auto;
      }

      #ar-start:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 4px;
      }

      #ar-prompt img {
        width: 70px;
      }

      #ar-unsupported {
        position: absolute;
        bottom: clamp(56px, 4vw, 88px);
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 5px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(201, 44, 44, 0.35);
        color: var(--danger);
        font-size: 12px;
        font-weight: 600;
        text-align: center;
        pointer-events: none;
        display: none;
      }

      .controls-grid {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .control-button {
        flex: 1 1 200px;
        padding: 12px 16px;
        font-size: 14px;
        font-weight: 600;
        background: var(--surface);
        color: var(--text-strong);
        border: 1px solid var(--border);
        border-radius: 12px;
        cursor: pointer;
        text-align: left;
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-height: 52px;
      }

      .control-button span[data-status] {
        font-size: 12px;
        color: var(--text-muted);
        font-weight: 500;
      }

      .control-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* ğŸ”§ ìˆ˜ì •: DOM Overlay ìŠ¤íƒ€ì¼ ê°œì„  */
      #ar-overlay {
        position: fixed;
        inset: 0;
        display: flex;  /* âœ… hidden ëŒ€ì‹  í•­ìƒ flexë¡œ ì„¤ì • */
        flex-direction: column;
        justify-content: flex-end;
        padding: 16px;
        padding-bottom: calc(16px + env(safe-area-inset-bottom));
        gap: 12px;
        pointer-events: none;  /* âœ… ê¸°ë³¸ì ìœ¼ë¡œ pointer-events: none */
        z-index: 999999;  /* âœ… z-indexë¥¼ ë§¤ìš° ë†’ê²Œ ì„¤ì • */
        visibility: hidden;  /* âœ… display ëŒ€ì‹  visibility ì‚¬ìš© */
        opacity: 0;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }

      /* âœ… AR í™œì„±í™” ì‹œ overlay í‘œì‹œ */
      #ar-overlay.dom-overlay-active {
        visibility: visible;
        opacity: 1;
        pointer-events: auto;  /* âœ… í™œì„±í™” ì‹œ pointer-events ë³µì› */
      }

      #ar-overlay .control-button {
        width: 100%;
        pointer-events: auto !important;  /* âœ… ë²„íŠ¼ì€ í•­ìƒ í´ë¦­ ê°€ëŠ¥í•˜ê²Œ */
        touch-action: manipulation;  /* âœ… í„°ì¹˜ ì´ë²¤íŠ¸ ìµœì í™” */
        -webkit-tap-highlight-color: transparent;  /* âœ… í„°ì¹˜ í•˜ì´ë¼ì´íŠ¸ ì œê±° */
        user-select: none;  /* âœ… í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ */
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }

        model-viewer {
          aspect-ratio: 3 / 4;
          border-radius: 20px;
        }

        .control-button {
          flex: 1 1 100%;
        }
      }
    </style>
  </head>
  <body>
    <!-- âœ… AR Overlayë¥¼ body ìµœìƒìœ„ë¡œ ì´ë™ -->
    <div id="ar-overlay">
      <button class="control-button" type="button" data-control="mode">
        ì• ë‹ˆë©”ì´ì…˜ ëª¨ë“œ ì „í™˜
        <span data-status>í˜„ì¬: ì²´ì–´ ëª¨ë“œ</span>
      </button>
      <button class="control-button" type="button" data-control="texture">
        í…ìŠ¤ì²˜ ì»¬ëŸ¬ ìˆœí™˜
        <span data-status>ê¸°ë³¸ â†’ Beige â†’ Olive</span>
      </button>
      <button class="control-button" type="button" data-control="rotate">
        90Â° íšŒì „
        <span data-status>í˜„ì¬ ê°ë„ ê¸°ì¤€</span>
      </button>
    </div>

    <main>
      <header>
        <h1>CERAGEM V11 AR Experience</h1>
      </header>

      <model-viewer
        id="cera-viewer"
        src="./src/CERA_V11_low_Draco6_WebP_4K_001_self_optimize.glb"
        poster="./img/V11_thumbnail.webp"
        alt="ì„¸ë¼ì ¬ V11 ì•ˆë§ˆì˜ì AR ì²´í—˜ ëª¨ë¸"
        shadow-intensity="1"
        camera-controls
        touch-action="pan-y"
        exposure="1"
        environment-image="neutral"
        ar
        ar-modes="webxr"
        ar-placement="floor"
        ar-scale="fixed"
        ar-dom-overlay="#ar-overlay"
      >
        <button slot="ar-button" id="ar-start" type="button">
          <img src="./img/AR in.png" alt="AR ì„¸ì…˜ ì‹œì‘">
        </button>
        <div id="ar-unsupported">í˜„ì¬ ë¸Œë¼ìš°ì €ëŠ” WebXR ARì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</div>
        <div slot="ar-prompt" id="ar-prompt">
          <img src="https://modelviewer.dev/shared-assets/icons/hand.png" alt="AR ì¡°ì‘ ì•ˆë‚´">
        </div>
        <div id="ar-failure" slot="ar-status">AR ì¶”ì  ë¬¸ì œ ë°œìƒ</div>
      </model-viewer>

      <div class="controls-grid" id="preview-controls">
        <button class="control-button" type="button" data-control="mode">
          ì• ë‹ˆë©”ì´ì…˜ ëª¨ë“œ ì „í™˜
          <span data-status>í˜„ì¬: ì²´ì–´ ëª¨ë“œ</span>
        </button>
        <button class="control-button" type="button" data-control="texture">
          í…ìŠ¤ì²˜ ì»¬ëŸ¬ ìˆœí™˜
          <span data-status>ê¸°ë³¸ â†’ Beige â†’ Olive</span>
        </button>
        <button class="control-button" type="button" data-control="rotate">
          90Â° íšŒì „
          <span data-status>í˜„ì¬ ê°ë„ ê¸°ì¤€</span>
        </button>
      </div>
    </main>

    <script type="module">
      const modelViewer = document.getElementById("cera-viewer");
      const arButton = document.getElementById("ar-start");
      const arUnsupportedMessage = document.getElementById("ar-unsupported");
      const overlayRoot = document.getElementById("ar-overlay");

      // âœ… DOM Overlay ê´€ë ¨ ìƒìˆ˜
      const XR_DOM_OVERLAY_FEATURE = "dom-overlay";
      const DOM_OVERLAY_ACTIVE_CLASS = "dom-overlay-active";
      const XR_REQUIRED_FEATURES = ["hit-test"];
      const XR_BASE_OPTIONAL_FEATURES = ["dom-overlay", "light-estimation"];

      const arUnsupportedDefaultText = "í˜„ì¬ ë¸Œë¼ìš°ì €ëŠ” WebXR ARì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
      const MIN_CAMERA_DISTANCE = 0.5;
      const MAX_CAMERA_DISTANCE = 5.0;

      let domOverlaySupported = true;

      // âœ… DOM Overlay ì´ˆê¸° ê²€ì¦
      if (!overlayRoot) {
        console.error("DOM Overlay root element (#ar-overlay) not found!");
        domOverlaySupported = false;
      }

      const modeButtons = document.querySelectorAll('[data-control="mode"]');
      const textureButtons = document.querySelectorAll('[data-control="texture"]');
      const rotateButtons = document.querySelectorAll('[data-control="rotate"]');

      const animationMap = {
        chair: { name: "CERA_V11_ChairMode(1)_Baked", label: "ì²´ì–´ ëª¨ë“œ" },
        stretch: { name: "CERA_V11_Stretch(1)_Baked", label: "ìŠ¤íŠ¸ë ˆì¹˜ ëª¨ë“œ" },
      };
      let currentMode = "chair";

      const textureSequence = [
        { key: "original", label: "ê¸°ë³¸ í…ìŠ¤ì²˜" },
        { key: "beige", label: "Beige í…ìŠ¤ì²˜", src: "./texture/CERA_V11_low_D_Beige.png" },
        { key: "olive", label: "Olive í…ìŠ¤ì²˜", src: "./texture/CERA_V11_low_D_Olive.png" },
      ];
      let currentTextureIndex = 0;
      const originalBaseTextures = new Map();
      const loadedTextures = new Map();

      let accumulatedRotation = 0;
      let rotationAnimationFrame = null;

      modelViewer?.addEventListener("load", () => {
        console.log('ğŸ¬ Model-Viewer ë¡œë“œ ì™„ë£Œ');
        console.log('ğŸ“ ar-dom-overlay ì†ì„±:', modelViewer.getAttribute('ar-dom-overlay'));
        console.log('ğŸ“ DOM Overlay ìš”ì†Œ ì¡´ì¬:', !!document.getElementById('ar-overlay'));
        console.log('ğŸ“ AR ì§€ì›:', modelViewer.canActivateAR);
        
        storeOriginalTextures();
        applyMode("chair", { immediate: true });
        ensureArButtonVisibility();
        applyCameraConstraints();
        setupDomOverlay();  // âœ… DOM Overlay ì„¤ì • ì¶”ê°€
      });

      // âœ… DOM Overlay ì„¤ì • í•¨ìˆ˜ ì¶”ê°€
      function setupDomOverlay() {
        if (!overlayRoot || !modelViewer) return;

        // AR ìƒíƒœ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ - updateOverlayPresentationState í•¨ìˆ˜ ì‚¬ìš©
        modelViewer.addEventListener('ar-status', updateOverlayPresentationState);
        
        // DOM overlay ì§€ì› ì—¬ë¶€ í™•ì¸
        console.log('ğŸ” DOM Overlay ìš”ì†Œ í™•ì¸:', overlayRoot);
        console.log('ğŸ” Model-Viewer AR DOM Overlay ì†ì„±:', modelViewer.getAttribute('ar-dom-overlay'));
      }

      modelViewer?.addEventListener("ar-status", (event) => {
        ensureArButtonVisibility();
        updateOverlayPresentationState(event);
      });

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const nextMode = currentMode === "chair" ? "stretch" : "chair";
          applyMode(nextMode);
        });
      });

      textureButtons.forEach((button) => {
        button.addEventListener("click", async () => {
          currentTextureIndex = (currentTextureIndex + 1) % textureSequence.length;
          const { key, src, label } = textureSequence[currentTextureIndex];
          await applyTextureVariant(key, src);
          updateTextureStatus(key, label);
        });
      });

      rotateButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const startAngle = accumulatedRotation;
          const targetAngle = startAngle + 90;
          const duration = 300;
          const startTime = performance.now();

          cancelAnimationFrame(rotationAnimationFrame);

          const animate = (timestamp) => {
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = easeOutCubic(progress);
            const currentAngle = startAngle + (targetAngle - startAngle) * eased;
            modelViewer.orientation = `0deg 0deg ${currentAngle}deg`;

            if (progress < 1) {
              rotationAnimationFrame = requestAnimationFrame(animate);
            } else {
              accumulatedRotation = targetAngle % 360;
            }
          };

          rotationAnimationFrame = requestAnimationFrame(animate);
        });
      });

      function applyMode(modeKey, { immediate = false } = {}) {
        if (!modelViewer || !animationMap[modeKey]) return;
        currentMode = modeKey;
        updateModeStatus();

        const animationName = animationMap[modeKey].name;
        modelViewer.animationName = animationName;

        if (immediate) {
          modelViewer.pause();
          modelViewer.currentTime = 0;
          return;
        }

        modelViewer.currentTime = 0;
        modelViewer.play({ repetitions: 1 });
        const handleFinished = () => {
          modelViewer.pause();
          modelViewer.removeEventListener("finished", handleFinished);
        };
        modelViewer.addEventListener("finished", handleFinished);
      }

      function updateModeStatus() {
        const statusText = `í˜„ì¬: ${animationMap[currentMode].label}`;
        modeButtons.forEach((button) => {
          const status = button.querySelector("[data-status]");
          if (status) status.textContent = statusText;
        });
      }

      function updateTextureStatus(key, label) {
        textureButtons.forEach((button) => {
          const status = button.querySelector("[data-status]");
          if (!status) return;
          status.textContent = key === "original" ? "ê¸°ë³¸ â†’ Beige â†’ Olive" : `${label} ì ìš© ì¤‘`;
        });
      }

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function storeOriginalTextures() {
        if (!modelViewer?.model) return;
        modelViewer.model.materials.forEach((material, index) => {
          const baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
          if (baseColorTexture && baseColorTexture.texture) {
            originalBaseTextures.set(index, index);
          }
        });
      }

      async function applyTextureVariant(key, src) {
        if (!modelViewer?.model) return;

        if (key === "original") {
          modelViewer.model.materials.forEach((material, idx) => {
            const originalTexture = originalBaseTextures.get(idx);
            if (originalTexture) {
              material.pbrMetallicRoughness.baseColorTexture.setTexture(originalTexture);
            }
          });
          return;
        }

        const texture = await loadTextureOnce(src);
        modelViewer.model.materials.forEach((material) => {
          if (material.pbrMetallicRoughness.baseColorTexture) {
            material.pbrMetallicRoughness.baseColorTexture.setTexture(texture);
          }
        });
      }

      async function loadTextureOnce(url) {
        if (!loadedTextures.has(url)) {
          loadedTextures.set(url, modelViewer.createTexture(url));
        }
        return loadedTextures.get(url);
      }

      function applyCameraConstraints() {
        if (!modelViewer) return;
        modelViewer.setAttribute("min-camera-orbit", `auto auto ${MIN_CAMERA_DISTANCE}m`);
        modelViewer.setAttribute("max-camera-orbit", `auto auto ${MAX_CAMERA_DISTANCE}m`);
      }

      function ensureArButtonVisibility() {
        if (!arButton) return;
        arButton.style.display = "inline-flex";
        if (!modelViewer?.canActivateAR || !domOverlaySupported) {
          arButton.setAttribute("disabled", "disabled");
          arButton.title = domOverlaySupported
            ? "ì§€ì›ë˜ì§€ ì•ŠëŠ” í™˜ê²½ì…ë‹ˆë‹¤."
            : "ì´ ë¸Œë¼ìš°ì €ëŠ” WebXR DOM Overlayë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
          if (arUnsupportedMessage) {
            arUnsupportedMessage.textContent = domOverlaySupported
              ? arUnsupportedDefaultText
              : "ì´ ë¸Œë¼ìš°ì €ëŠ” WebXR DOM Overlayë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
            arUnsupportedMessage.style.display = "block";
          }
        } else {
          arButton.removeAttribute("disabled");
          arButton.title = "AR ì„¸ì…˜ ì‹œì‘";
          if (arUnsupportedMessage) {
            arUnsupportedMessage.textContent = arUnsupportedDefaultText;
            arUnsupportedMessage.style.display = "none";
          }
        }
      }

      // âœ… ìˆ˜ì •: model-viewerì˜ ìì²´ AR ê´€ë¦¬ë¥¼ í™œìš©
      function updateOverlayPresentationState(event) {
        if (!overlayRoot) return;
        const detail = event?.detail;
        const status = typeof detail === "string" ? detail : detail?.status;
        
        console.log('ğŸ”„ AR Status ë³€ê²½:', status);
        console.log('ğŸ“ Overlay ìš”ì†Œ:', overlayRoot);
        
        if (status === "session-started") {
          console.log('âœ… AR ì„¸ì…˜ ì‹œì‘ - DOM Overlay í™œì„±í™” ì‹œë„');
          overlayRoot.classList.add(DOM_OVERLAY_ACTIVE_CLASS);
          
          // DOM Overlay ìƒíƒœ ìƒì„¸ í™•ì¸
          setTimeout(() => {
            if (modelViewer?.xrSession) {
              console.log('ğŸ¯ XR Session í™•ì¸:', modelViewer.xrSession);
              const domOverlayState = modelViewer.xrSession.domOverlayState;
              if (domOverlayState) {
                console.log('âœ… DOM Overlay í™œì„± ìƒíƒœ:', domOverlayState);
                console.log('âœ… DOM Overlay Type:', domOverlayState.type);
              } else {
                console.warn('âš ï¸ DOM Overlayê°€ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                console.warn('âš ï¸ ë¸Œë¼ìš°ì €ê°€ DOM Overlayë¥¼ ì§€ì›í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
              }
              
              // í™œì„±í™”ëœ features í™•ì¸
              if (modelViewer.xrSession.enabledFeatures) {
                console.log('ğŸ“‹ í™œì„±í™”ëœ XR Features:', Array.from(modelViewer.xrSession.enabledFeatures));
              }
            }
          }, 100);
          
        } else if (status === "not-presenting" || status === "failed" || status === "session-ended") {
          console.log('ğŸ”´ AR ì„¸ì…˜ ì¢…ë£Œ - DOM Overlay ë¹„í™œì„±í™”');
          overlayRoot.classList.remove(DOM_OVERLAY_ACTIVE_CLASS);
        }
      }

      // âœ… ìˆ˜ì •: AR ë²„íŠ¼ í´ë¦­ ì‹œ DOM overlay ìë™ ì²˜ë¦¬
      arButton?.addEventListener("click", async (event) => {
        event.preventDefault();
        if (!modelViewer) return;
        if (!modelViewer.canActivateAR) {
          console.warn("í˜„ì¬ í™˜ê²½ì€ WebXR ARì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
          return;
        }

        console.log('ğŸš€ AR ì„¸ì…˜ ì‹œì‘ ì‹œë„...');
        console.log('ğŸ“ DOM Overlay ì†ì„±:', modelViewer.getAttribute('ar-dom-overlay'));
        
        // âœ… model-viewerê°€ ar-dom-overlay ì†ì„±ì„ í†µí•´ ìë™ìœ¼ë¡œ DOM overlay ì²˜ë¦¬
        try {
          await modelViewer.activateAR();
          console.log('âœ… AR ì„¸ì…˜ ì‹œì‘ ì„±ê³µ');
        } catch (error) {
          console.error('âŒ AR ì„¸ì…˜ ì‹œì‘ ì‹¤íŒ¨:', error);
          
          if (error?.name === "NotSupportedError" || /\bdom[- ]?overlay\b/i.test(error?.message ?? "")) {
            console.error("ì´ ë¸Œë¼ìš°ì €ëŠ” WebXR DOM Overlayë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", error);
            domOverlaySupported = false;
            if (overlayRoot) {
              overlayRoot.classList.remove(DOM_OVERLAY_ACTIVE_CLASS);
            }
            if (arUnsupportedMessage) {
              arUnsupportedMessage.textContent = "ì´ ë¸Œë¼ìš°ì €ëŠ” WebXR DOM Overlayë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";
              arUnsupportedMessage.style.display = "block";
            }
            arButton?.setAttribute("disabled", "disabled");
            ensureArButtonVisibility();
          } else {
            console.error("AR ì„¸ì…˜ ì§„ì…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:", error);
          }
        }
      });
    </script>
  </body>
</html>
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>CERAGEM V11 WebXR Demo</title>
    <meta name="description" content="CERAGEM V11 제품을 WebXR 기반 AR 환경에서 체험하며 모드, 재질, 회전을 제어할 수 있는 프로토타입">
    <!-- 한국어 주석: CORS 이슈 방지를 위해 로컬에 저장한 model-viewer 모듈 사용 -->
    <script type="module" src="./libs/model-viewer.min.js"></script>
    <style>
      :root {
        color-scheme: light;
        --bg-base: #f7f8fa;
        --surface: #ffffff;
        --border: #d8dbe3;
        --text-strong: #1d1f24;
        --text-muted: #5b6578;
        --accent: #2f54eb;
        --accent-soft: rgba(47, 84, 235, 0.1);
        --danger: #c92c2c;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Pretendard", "Noto Sans KR", "Segoe UI", sans-serif;
        background: var(--bg-base);
        color: var(--text-strong);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        padding: clamp(16px, 4vw, 40px);
      }

      main {
        width: min(1280px, 100%);
        display: grid;
        gap: clamp(16px, 3vw, 28px);
      }

      header {
        padding: 4px 0;
      }

      header h1 {
        margin: 0;
        font-size: clamp(24px, 3vw, 32px);
        font-weight: 600;
        letter-spacing: -0.01em;
      }

      model-viewer {
        width: 100%;
        aspect-ratio: 4 / 3;
        min-height: clamp(420px, 60vh, 720px);
        border-radius: 24px;
        background: var(--surface);
        border: 1px solid var(--border);
        --poster-color: #eef0f6;
        --progress-bar-height: 4px;
        --progress-bar-color: rgba(47, 84, 235, 0.7);
        position: relative;
        --ar-button-display: block;
      }

      #ar-start {
        position: absolute;
        bottom: clamp(12px, 2vw, 20px);
        right: 20px;
        padding: 0;
        border: none;
        background: transparent;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        cursor: pointer;
        transform: none;
      }

      #ar-start[disabled] {
        opacity: 0.45;
        cursor: not-allowed;
      }

      #ar-start img {
        display: block;
        width: clamp(50px, 13.5vw, 50px);
        height: auto;
      }

      #ar-start:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 4px;
      }

      #ar-prompt img {
        width: 70px;
      }

      #ar-unsupported {
        position: absolute;
        bottom: clamp(56px, 4vw, 88px);
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 5px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(201, 44, 44, 0.35);
        color: var(--danger);
        font-size: 12px;
        font-weight: 600;
        text-align: center;
        pointer-events: none;
        display: none;
      }

      .controls-grid {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .control-button {
        flex: 1 1 200px;
        padding: 12px 16px;
        font-size: 14px;
        font-weight: 600;
        background: var(--surface);
        color: var(--text-strong);
        border: 1px solid var(--border);
        border-radius: 12px;
        cursor: pointer;
        text-align: left;
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-height: 52px;
      }

      .control-button span[data-status] {
        font-size: 12px;
        color: var(--text-muted);
        font-weight: 500;
      }

      .control-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #ar-overlay {
        position: fixed;
        inset: 0;
        display: none;
        flex-direction: column;
        justify-content: flex-end;
        padding: 16px;
        padding-bottom: calc(16px + env(safe-area-inset-bottom));
        gap: 12px;
        pointer-events: auto;
        z-index: 10;
      }

      #ar-overlay.dom-overlay-active {
        display: flex;
      }
      /* Also show overlay based on <model-viewer> ar-status */
      model-viewer[ar-status="session-started"] #ar-overlay,
      model-viewer[ar-status="object-placed"] #ar-overlay { display: flex; }
      model-viewer[ar-status="failed"] #ar-overlay { display: none; }


      #ar-overlay .control-button {
        width: 100%;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }

        model-viewer {
          aspect-ratio: 3 / 4;
          border-radius: 20px;
        }

        .control-button {
          flex: 1 1 100%;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <h1>CERAGEM V11 AR Experience</h1>
      </header>

      <model-viewer
        id="cera-viewer"
        src="./src/CERA_V11_low_Draco6_WebP_4K_001_self_optimize.glb"
        poster="./img/V11_thumbnail.webp"
        alt="세라젬 V11 안마의자 AR 체험 모델"
        shadow-intensity="1"
        camera-controls
        touch-action="pan-y"
        exposure="1"
        environment-image="neutral"
        ar
        ar-modes="webxr"
        ar-placement="floor"
        ar-scale="fixed"
        ar-dom-overlay="ar-overlay"
      >
        <button slot="ar-button" id="ar-start" type="button">
          <img src="./img/AR in.png" alt="AR 세션 시작">
        </button>
        <div id="ar-unsupported">현재 브라우저는 WebXR AR을 지원하지 않습니다.</div>
        <div slot="ar-prompt" id="ar-prompt">
          <img src="https://modelviewer.dev/shared-assets/icons/hand.png" alt="AR 조작 안내">
        </div>
        <div id="ar-failure" slot="ar-status">AR 추적 문제 발생</div>

        <div id="ar-overlay" slot="ar-dom-overlay">
          <button class="control-button" type="button" data-control="mode">
            애니메이션 모드 전환
            <span data-status>현재: 체어 모드</span>
          </button>
          <button class="control-button" type="button" data-control="texture">
            텍스처 컬러 순환
            <span data-status>기본 → Beige → Olive</span>
          </button>
          <button class="control-button" type="button" data-control="rotate">
            90° 회전
            <span data-status>현재 각도 기준</span>
          </button>
        </div>
      </model-viewer>

      <div class="controls-grid" id="preview-controls">
        <button class="control-button" type="button" data-control="mode">
          애니메이션 모드 전환
          <span data-status>현재: 체어 모드</span>
        </button>
        <button class="control-button" type="button" data-control="texture">
          텍스처 컬러 순환
          <span data-status>기본 → Beige → Olive</span>
        </button>
        <button class="control-button" type="button" data-control="rotate">
          90° 회전
          <span data-status>현재 각도 기준</span>
        </button>
        <button class="control-button" type="button" disabled>
          치수 표시 (준비 중)
          <span data-status>향후 업데이트 예정</span>
        </button>
      </div>
    </main>

    <script type="module">
      // 한국어 주석: 전역 DOM 참조 및 공유 상태 값 선언
      const modelViewer = document.querySelector("#cera-viewer");
      const modeButtons = Array.from(document.querySelectorAll('button[data-control="mode"]'));
      const textureButtons = Array.from(document.querySelectorAll('button[data-control="texture"]'));
      const rotateButtons = Array.from(document.querySelectorAll('button[data-control="rotate"]'));
      const arButton = document.querySelector("#ar-start");
      const arUnsupportedMessage = document.getElementById("ar-unsupported");
      const overlayRoot = document.getElementById("ar-overlay");
      // Prevent XR gesture capture when tapping overlay controls
      overlayRoot?.querySelectorAll('.control-button')?.forEach((btn) => {
        btn.addEventListener('beforexrselect', (ev) => ev.preventDefault());
      });

      // WebXR feature configuration so DOM overlay can be requested consistently.
      const XR_REQUIRED_FEATURES = ["hit-test"];
      const XR_DOM_OVERLAY_FEATURE = "dom-overlay";
      const XR_BASE_OPTIONAL_FEATURES = ["light-estimation"];
      const DOM_OVERLAY_ACTIVE_CLASS = "dom-overlay-active";
      let domOverlaySupported = true;
      const arUnsupportedDefaultText = arUnsupportedMessage?.textContent ?? "";

      if (!modelViewer) {
        console.error("model-viewer 요소를 찾을 수 없습니다.");
      }
      if (!overlayRoot) {
        console.warn("DOM overlay 루트를 찾을 수 없습니다. AR 세션에서 HTML overlay를 사용할 수 없습니다.");
        domOverlaySupported = false;
      }
      ensureArButtonVisibility();

      // 한국어 주석: 사용자 정의 가능한 카메라 줌 범위(단위: 미터). 필요 시 값만 수정하세요.
      const MIN_CAMERA_DISTANCE = 1.4;
      const MAX_CAMERA_DISTANCE = 4.5;

      // 한국어 주석: 애니메이션 토글(체어 ↔ 스트레치)
      const animationMap = {
        chair: { name: "CERA_V11_ChairMode(1)_Baked", label: "체어 모드" },
        stretch: { name: "CERA_V11_Stretch(1)_Baked", label: "스트레치 모드" },
      };
      let currentMode = "chair";

      // 한국어 주석: 텍스처 순환(기본 → Beige → Olive)
      const textureSequence = [
        { key: "original", label: "기본 텍스처" },
        { key: "beige", label: "Beige 텍스처", src: "./texture/CERA_V11_low_D_Beige.png" },
        { key: "olive", label: "Olive 텍스처", src: "./texture/CERA_V11_low_D_Olive.png" },
      ];
      let currentTextureIndex = 0;
      const originalBaseTextures = new Map();
      const loadedTextures = new Map();

      // 한국어 주석: 회전 애니메이션 상태
      let accumulatedRotation = 0;
      let rotationAnimationFrame = null;

      modelViewer?.addEventListener("load", () => {
        storeOriginalTextures();
        applyMode("chair", { immediate: true });
        ensureArButtonVisibility();
        applyCameraConstraints();
      });

      modelViewer?.addEventListener("ar-status", (event) => {
        ensureArButtonVisibility();
        updateOverlayPresentationState(event);
      });

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const nextMode = currentMode === "chair" ? "stretch" : "chair";
          applyMode(nextMode);
        });
      });

      textureButtons.forEach((button) => {
        button.addEventListener("click", async () => {
          currentTextureIndex = (currentTextureIndex + 1) % textureSequence.length;
          const { key, src, label } = textureSequence[currentTextureIndex];
          await applyTextureVariant(key, src);
          updateTextureStatus(key, label);
        });
      });

      rotateButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const startAngle = accumulatedRotation;
          const targetAngle = startAngle + 90;
          const duration = 300;
          const startTime = performance.now();

          cancelAnimationFrame(rotationAnimationFrame);

          const animate = (timestamp) => {
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = easeOutCubic(progress);
            const currentAngle = startAngle + (targetAngle - startAngle) * eased;
            modelViewer.orientation = `0deg 0deg ${currentAngle}deg`;

            if (progress < 1) {
              rotationAnimationFrame = requestAnimationFrame(animate);
            } else {
              accumulatedRotation = targetAngle % 360;
            }
          };

          rotationAnimationFrame = requestAnimationFrame(animate);
        });
      });

      function applyMode(modeKey, { immediate = false } = {}) {
        if (!modelViewer || !animationMap[modeKey]) return;
        currentMode = modeKey;
        updateModeStatus();

        const animationName = animationMap[modeKey].name;
        modelViewer.animationName = animationName;

        if (immediate) {
          modelViewer.pause();
          modelViewer.currentTime = 0;
          return;
        }

        modelViewer.currentTime = 0;
        modelViewer.play({ repetitions: 1 });
        const handleFinished = () => {
          modelViewer.pause();
          modelViewer.removeEventListener("finished", handleFinished);
        };
        modelViewer.addEventListener("finished", handleFinished);
      }

      function updateModeStatus() {
        const statusText = `현재: ${animationMap[currentMode].label}`;
        modeButtons.forEach((button) => {
          const status = button.querySelector("[data-status]");
          if (status) status.textContent = statusText;
        });
      }

      function updateTextureStatus(key, label) {
        textureButtons.forEach((button) => {
          const status = button.querySelector("[data-status]");
          if (!status) return;
          status.textContent = key === "original" ? "기본 → Beige → Olive" : `${label} 적용 중`;
        });
      }

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function storeOriginalTextures() {
        if (!modelViewer?.model) return;
        modelViewer.model.materials.forEach((material, index) => {
          const baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
          if (baseColorTexture && baseColorTexture.texture) {
            originalBaseTextures.set(index, baseColorTexture.texture);
          }
        });
      }

      async function applyTextureVariant(key, src) {
        if (!modelViewer?.model) return;

        if (key === "original") {
          modelViewer.model.materials.forEach((material, idx) => {
            const originalTexture = originalBaseTextures.get(idx);
            if (originalTexture) {
              material.pbrMetallicRoughness.baseColorTexture.setTexture(originalTexture);
            }
          });
          return;
        }

        const texture = await loadTextureOnce(src);
        modelViewer.model.materials.forEach((material) => {
          if (material.pbrMetallicRoughness.baseColorTexture) {
            material.pbrMetallicRoughness.baseColorTexture.setTexture(texture);
          }
        });
      }

      async function loadTextureOnce(url) {
        if (!loadedTextures.has(url)) {
          loadedTextures.set(url, modelViewer.createTexture(url));
        }
        return loadedTextures.get(url);
      }

      function applyCameraConstraints() {
        if (!modelViewer) return;
        modelViewer.setAttribute("min-camera-orbit", `auto auto ${MIN_CAMERA_DISTANCE}m`);
        modelViewer.setAttribute("max-camera-orbit", `auto auto ${MAX_CAMERA_DISTANCE}m`);
      }

      function ensureArButtonVisibility() {
        if (!arButton) return;
        arButton.style.display = "inline-flex";
        if (!modelViewer?.canActivateAR || !domOverlaySupported) {
          arButton.setAttribute("disabled", "disabled");
          arButton.title = domOverlaySupported
            ? "지원되지 않는 환경입니다."
            : "이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.";
          if (arUnsupportedMessage) {
            arUnsupportedMessage.textContent = domOverlaySupported
              ? arUnsupportedDefaultText
              : "이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.";
            arUnsupportedMessage.style.display = "block";
          }
        } else {
          arButton.removeAttribute("disabled");
          arButton.title = "AR 세션 시작";
          if (arUnsupportedMessage) {
            arUnsupportedMessage.textContent = arUnsupportedDefaultText;
            arUnsupportedMessage.style.display = "none";
          }
        }
      }

      function buildArSessionOptions() {
        const requiredFeatures = new Set(XR_REQUIRED_FEATURES);
        const optionalFeatures = new Set(XR_BASE_OPTIONAL_FEATURES);
        const sessionOptions = {
          xrSessionMode: "immersive-ar",
        };
        if (overlayRoot) {
          requiredFeatures.add(XR_DOM_OVERLAY_FEATURE);
          sessionOptions.domOverlay = { root: overlayRoot };
        }
        sessionOptions.requiredFeatures = Array.from(requiredFeatures);
        sessionOptions.optionalFeatures = Array.from(optionalFeatures);
        return sessionOptions;
      }

      function updateOverlayPresentationState(event) {
        if (!overlayRoot) return;
        const detail = event?.detail;
        const status = typeof detail === "string" ? detail : detail?.status;
        if (status === "session-started") {
          overlayRoot.classList.add(DOM_OVERLAY_ACTIVE_CLASS);
          overlayRoot.removeAttribute("hidden");
          const domOverlayState = modelViewer?.xrSession?.domOverlayState;
          if (!domOverlayState) {
            console.warn("DOM overlay was requested but is not available in this XR session.");
          } else if (domOverlayState?.type) {
            console.info(`DOM overlay type: ${domOverlayState.type}`);
          }
        } else if (status === "not-presenting" || status === "failed" || status === "session-ended") {
          overlayRoot.classList.remove(DOM_OVERLAY_ACTIVE_CLASS);
          overlayRoot.setAttribute("hidden", "hidden");
        }
      }

      arButton?.addEventListener("click", async (event) => {
        event.preventDefault();
        if (!modelViewer) return;
        if (!modelViewer.canActivateAR) {
          console.warn("현재 환경은 WebXR AR을 지원하지 않습니다.");
          return;
        }
        try {
          const sessionOptions = buildArSessionOptions();
          await modelViewer.enterAR();
        } catch (error) {
          if (error?.name === "NotSupportedError" || /\bdom[- ]?overlay\b/i.test(error?.message ?? "")) {
            console.error("이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.", error);
            domOverlaySupported = false;
            if (overlayRoot) {
              overlayRoot.classList.remove(DOM_OVERLAY_ACTIVE_CLASS);
              overlayRoot.setAttribute("hidden", "hidden");
            }
            if (arUnsupportedMessage) {
              arUnsupportedMessage.textContent = "이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.";
              arUnsupportedMessage.style.display = "block";
            }
            arButton?.setAttribute("disabled", "disabled");
            ensureArButtonVisibility();
          } else {
            console.error("AR 세션 진입에 실패했습니다:", error);
          }
        }
      });

      // 한국어 주석: 치수 기능은 비활성화 상태로 유지
    </script>
  </body>
</html>

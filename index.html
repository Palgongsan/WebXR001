<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>CERAGEM V11 WebXR Demo</title>
    <meta name="description" content="CERAGEM V11 제품을 WebXR 기반 AR 환경에서 체험하며 모드, 재질, 회전을 제어할 수 있는 프로토타입">
    <!-- 한국어 주석: CORS 이슈 방지를 위해 로컬에 저장한 model-viewer 모듈 사용 -->
    <script type="module" src="./libs/model-viewer.min.js"></script>
    <style>
      :root {
        color-scheme: light;
        --bg-base: #f7f8fa;
        --surface: #ffffff;
        --border: #d8dbe3;
        --text-strong: #1d1f24;
        --text-muted: #5b6578;
        --accent: #2f54eb;
        --accent-soft: rgba(47, 84, 235, 0.1);
        --danger: #c92c2c;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Pretendard", "Noto Sans KR", "Segoe UI", sans-serif;
        background: var(--bg-base);
        color: var(--text-strong);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        padding: clamp(16px, 4vw, 40px);
      }

      main {
        width: min(1280px, 100%);
        display: grid;
        gap: clamp(16px, 3vw, 28px);
      }

      header {
        padding: 4px 0;
      }

      header h1 {
        margin: 0;
        font-size: clamp(24px, 3vw, 32px);
        font-weight: 600;
        letter-spacing: -0.01em;
      }

      model-viewer {
        width: 100%;
        aspect-ratio: 4 / 3;
        min-height: clamp(420px, 60vh, 720px);
        border-radius: 24px;
        background: var(--surface);
        border: 1px solid var(--border);
        --poster-color: #eef0f6;
        --progress-bar-height: 4px;
        --progress-bar-color: rgba(47, 84, 235, 0.7);
        position: relative;
        --ar-button-display: block;
      }

      #ar-start {
        position: absolute;
        bottom: clamp(12px, 2vw, 20px);
        right: 20px;
        padding: 0;
        border: none;
        background: transparent;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        cursor: pointer;
        transform: none;
      }

      #ar-start[disabled] {
        opacity: 0.45;
        cursor: not-allowed;
      }

      #ar-start img {
        display: block;
        width: clamp(50px, 13.5vw, 50px);
        height: auto;
      }

      #ar-start:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 4px;
      }

      #ar-prompt img {
        width: 70px;
      }

      #ar-unsupported {
        position: absolute;
        bottom: clamp(56px, 4vw, 88px);
        left: 50%;
        transform: translateX(-50%);
        padding: 5px 5px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(201, 44, 44, 0.35);
        color: var(--danger);
        font-size: 12px;
        font-weight: 600;
        text-align: center;
        pointer-events: none;
        display: none;
      }

      .controls-grid {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .control-button {
        flex: 1 1 200px;
        padding: 12px 16px;
        font-size: 14px;
        font-weight: 600;
        background: var(--surface);
        color: var(--text-strong);
        border: 1px solid var(--border);
        border-radius: 12px;
        cursor: pointer;
        text-align: left;
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-height: 52px;
      }

      .control-button span[data-status] {
        font-size: 12px;
        color: var(--text-muted);
        font-weight: 500;
      }

      .control-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* 🔧 수정: DOM Overlay 스타일 개선 */
      #ar-overlay {
        position: fixed;
        inset: 0;
        display: flex;  /* ✅ hidden 대신 항상 flex로 설정 */
        flex-direction: column;
        justify-content: flex-end;
        padding: 16px;
        padding-bottom: calc(16px + env(safe-area-inset-bottom));
        gap: 12px;
        pointer-events: none;  /* ✅ 기본적으로 pointer-events: none */
        z-index: 10;
        visibility: hidden;  /* ✅ display 대신 visibility 사용 */
        opacity: 0;
        transition: opacity 0.2s ease, visibility 0.2s ease;
      }

      /* ✅ AR 활성화 시 overlay 표시 */
      #ar-overlay.dom-overlay-active {
        visibility: visible;
        opacity: 1;
        pointer-events: auto;  /* ✅ 활성화 시 pointer-events 복원 */
      }

      #ar-overlay .control-button {
        width: 100%;
        pointer-events: auto;  /* ✅ 버튼은 항상 클릭 가능하게 */
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      @media (max-width: 768px) {
        body {
          padding: 16px;
        }

        model-viewer {
          aspect-ratio: 3 / 4;
          border-radius: 20px;
        }

        .control-button {
          flex: 1 1 100%;
        }
      }
    </style>
  </head>
  <body>
    <!-- ✅ AR Overlay를 body 최상위로 이동 -->
    <div id="ar-overlay">
      <button class="control-button" type="button" data-control="mode">
        애니메이션 모드 전환
        <span data-status>현재: 체어 모드</span>
      </button>
      <button class="control-button" type="button" data-control="texture">
        텍스처 컬러 순환
        <span data-status>기본 → Beige → Olive</span>
      </button>
      <button class="control-button" type="button" data-control="rotate">
        90° 회전
        <span data-status>현재 각도 기준</span>
      </button>
    </div>

    <main>
      <header>
        <h1>CERAGEM V11 AR Experience</h1>
      </header>

      <model-viewer
        id="cera-viewer"
        src="./src/CERA_V11_low_Draco6_WebP_4K_001_self_optimize.glb"
        poster="./img/V11_thumbnail.webp"
        alt="세라젬 V11 안마의자 AR 체험 모델"
        shadow-intensity="1"
        camera-controls
        touch-action="pan-y"
        exposure="1"
        environment-image="neutral"
        ar
        ar-modes="webxr"
        ar-placement="floor"
        ar-scale="fixed"
      >
        <button slot="ar-button" id="ar-start" type="button">
          <img src="./img/AR in.png" alt="AR 세션 시작">
        </button>
        <div id="ar-unsupported">현재 브라우저는 WebXR AR을 지원하지 않습니다.</div>
        <div slot="ar-prompt" id="ar-prompt">
          <img src="https://modelviewer.dev/shared-assets/icons/hand.png" alt="AR 조작 안내">
        </div>
        <div id="ar-failure" slot="ar-status">AR 추적 문제 발생</div>
      </model-viewer>

      <div class="controls-grid" id="preview-controls">
        <button class="control-button" type="button" data-control="mode">
          애니메이션 모드 전환
          <span data-status>현재: 체어 모드</span>
        </button>
        <button class="control-button" type="button" data-control="texture">
          텍스처 컬러 순환
          <span data-status>기본 → Beige → Olive</span>
        </button>
        <button class="control-button" type="button" data-control="rotate">
          90° 회전
          <span data-status>현재 각도 기준</span>
        </button>
      </div>
    </main>

    <script type="module">
      const modelViewer = document.getElementById("cera-viewer");
      const arButton = document.getElementById("ar-start");
      const arUnsupportedMessage = document.getElementById("ar-unsupported");
      const overlayRoot = document.getElementById("ar-overlay");

      // ✅ DOM Overlay 관련 상수
      const XR_DOM_OVERLAY_FEATURE = "dom-overlay";
      const DOM_OVERLAY_ACTIVE_CLASS = "dom-overlay-active";
      const XR_REQUIRED_FEATURES = ["hit-test"];
      const XR_BASE_OPTIONAL_FEATURES = ["dom-overlay", "light-estimation"];

      const arUnsupportedDefaultText = "현재 브라우저는 WebXR AR을 지원하지 않습니다.";
      const MIN_CAMERA_DISTANCE = 0.5;
      const MAX_CAMERA_DISTANCE = 5.0;

      let domOverlaySupported = true;

      // ✅ DOM Overlay 초기 검증
      if (!overlayRoot) {
        console.error("DOM Overlay root element (#ar-overlay) not found!");
        domOverlaySupported = false;
      }

      const modeButtons = document.querySelectorAll('[data-control="mode"]');
      const textureButtons = document.querySelectorAll('[data-control="texture"]');
      const rotateButtons = document.querySelectorAll('[data-control="rotate"]');

      const animationMap = {
        chair: { name: "CERA_V11_ChairMode(1)_Baked", label: "체어 모드" },
        stretch: { name: "CERA_V11_Stretch(1)_Baked", label: "스트레치 모드" },
      };
      let currentMode = "chair";

      const textureSequence = [
        { key: "original", label: "기본 텍스처" },
        { key: "beige", label: "Beige 텍스처", src: "./texture/CERA_V11_low_D_Beige.png" },
        { key: "olive", label: "Olive 텍스처", src: "./texture/CERA_V11_low_D_Olive.png" },
      ];
      let currentTextureIndex = 0;
      const originalBaseTextures = new Map();
      const loadedTextures = new Map();

      let accumulatedRotation = 0;
      let rotationAnimationFrame = null;

      modelViewer?.addEventListener("load", () => {
        storeOriginalTextures();
        applyMode("chair", { immediate: true });
        ensureArButtonVisibility();
        applyCameraConstraints();
        setupDomOverlay();  // ✅ DOM Overlay 설정 추가
      });

      // ✅ DOM Overlay 설정 함수 추가
      function setupDomOverlay() {
        if (!overlayRoot || !modelViewer) return;

        // model-viewer에 DOM overlay 설정
        modelViewer.setAttribute('ar-modes', 'webxr');
        
        // XR 세션이 시작될 때 overlay 활성화
        modelViewer.addEventListener('ar-status', (event) => {
          const status = event.detail.status;
          console.log('AR Status:', status);
          
          if (status === 'session-started') {
            console.log('✅ AR 세션 시작 - Overlay 활성화');
            overlayRoot.classList.add(DOM_OVERLAY_ACTIVE_CLASS);
            
            // XR 세션 정보 확인
            if (modelViewer.xrSession) {
              const domOverlayState = modelViewer.xrSession.domOverlayState;
              if (domOverlayState) {
                console.log('✅ DOM Overlay 활성:', domOverlayState.type);
              } else {
                console.warn('⚠️ DOM Overlay가 활성화되지 않았습니다.');
              }
            }
          } else if (status === 'not-presenting' || status === 'failed' || status === 'session-ended') {
            console.log('❌ AR 세션 종료 - Overlay 비활성화');
            overlayRoot.classList.remove(DOM_OVERLAY_ACTIVE_CLASS);
          }
        });
      }

      modelViewer?.addEventListener("ar-status", (event) => {
        ensureArButtonVisibility();
        updateOverlayPresentationState(event);
      });

      modeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const nextMode = currentMode === "chair" ? "stretch" : "chair";
          applyMode(nextMode);
        });
      });

      textureButtons.forEach((button) => {
        button.addEventListener("click", async () => {
          currentTextureIndex = (currentTextureIndex + 1) % textureSequence.length;
          const { key, src, label } = textureSequence[currentTextureIndex];
          await applyTextureVariant(key, src);
          updateTextureStatus(key, label);
        });
      });

      rotateButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const startAngle = accumulatedRotation;
          const targetAngle = startAngle + 90;
          const duration = 300;
          const startTime = performance.now();

          cancelAnimationFrame(rotationAnimationFrame);

          const animate = (timestamp) => {
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const eased = easeOutCubic(progress);
            const currentAngle = startAngle + (targetAngle - startAngle) * eased;
            modelViewer.orientation = `0deg 0deg ${currentAngle}deg`;

            if (progress < 1) {
              rotationAnimationFrame = requestAnimationFrame(animate);
            } else {
              accumulatedRotation = targetAngle % 360;
            }
          };

          rotationAnimationFrame = requestAnimationFrame(animate);
        });
      });

      function applyMode(modeKey, { immediate = false } = {}) {
        if (!modelViewer || !animationMap[modeKey]) return;
        currentMode = modeKey;
        updateModeStatus();

        const animationName = animationMap[modeKey].name;
        modelViewer.animationName = animationName;

        if (immediate) {
          modelViewer.pause();
          modelViewer.currentTime = 0;
          return;
        }

        modelViewer.currentTime = 0;
        modelViewer.play({ repetitions: 1 });
        const handleFinished = () => {
          modelViewer.pause();
          modelViewer.removeEventListener("finished", handleFinished);
        };
        modelViewer.addEventListener("finished", handleFinished);
      }

      function updateModeStatus() {
        const statusText = `현재: ${animationMap[currentMode].label}`;
        modeButtons.forEach((button) => {
          const status = button.querySelector("[data-status]");
          if (status) status.textContent = statusText;
        });
      }

      function updateTextureStatus(key, label) {
        textureButtons.forEach((button) => {
          const status = button.querySelector("[data-status]");
          if (!status) return;
          status.textContent = key === "original" ? "기본 → Beige → Olive" : `${label} 적용 중`;
        });
      }

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function storeOriginalTextures() {
        if (!modelViewer?.model) return;
        modelViewer.model.materials.forEach((material, index) => {
          const baseColorTexture = material.pbrMetallicRoughness.baseColorTexture;
          if (baseColorTexture && baseColorTexture.texture) {
            originalBaseTextures.set(index, index);
          }
        });
      }

      async function applyTextureVariant(key, src) {
        if (!modelViewer?.model) return;

        if (key === "original") {
          modelViewer.model.materials.forEach((material, idx) => {
            const originalTexture = originalBaseTextures.get(idx);
            if (originalTexture) {
              material.pbrMetallicRoughness.baseColorTexture.setTexture(originalTexture);
            }
          });
          return;
        }

        const texture = await loadTextureOnce(src);
        modelViewer.model.materials.forEach((material) => {
          if (material.pbrMetallicRoughness.baseColorTexture) {
            material.pbrMetallicRoughness.baseColorTexture.setTexture(texture);
          }
        });
      }

      async function loadTextureOnce(url) {
        if (!loadedTextures.has(url)) {
          loadedTextures.set(url, modelViewer.createTexture(url));
        }
        return loadedTextures.get(url);
      }

      function applyCameraConstraints() {
        if (!modelViewer) return;
        modelViewer.setAttribute("min-camera-orbit", `auto auto ${MIN_CAMERA_DISTANCE}m`);
        modelViewer.setAttribute("max-camera-orbit", `auto auto ${MAX_CAMERA_DISTANCE}m`);
      }

      function ensureArButtonVisibility() {
        if (!arButton) return;
        arButton.style.display = "inline-flex";
        if (!modelViewer?.canActivateAR || !domOverlaySupported) {
          arButton.setAttribute("disabled", "disabled");
          arButton.title = domOverlaySupported
            ? "지원되지 않는 환경입니다."
            : "이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.";
          if (arUnsupportedMessage) {
            arUnsupportedMessage.textContent = domOverlaySupported
              ? arUnsupportedDefaultText
              : "이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.";
            arUnsupportedMessage.style.display = "block";
          }
        } else {
          arButton.removeAttribute("disabled");
          arButton.title = "AR 세션 시작";
          if (arUnsupportedMessage) {
            arUnsupportedMessage.textContent = arUnsupportedDefaultText;
            arUnsupportedMessage.style.display = "none";
          }
        }
      }

      // ✅ 수정: model-viewer의 자체 AR 관리를 활용
      function updateOverlayPresentationState(event) {
        if (!overlayRoot) return;
        const detail = event?.detail;
        const status = typeof detail === "string" ? detail : detail?.status;
        
        console.log('Overlay State Update:', status);
        
        if (status === "session-started") {
          overlayRoot.classList.add(DOM_OVERLAY_ACTIVE_CLASS);
          const domOverlayState = modelViewer?.xrSession?.domOverlayState;
          if (!domOverlayState) {
            console.warn("DOM overlay was requested but is not available in this XR session.");
          } else if (domOverlayState?.type) {
            console.info(`DOM overlay type: ${domOverlayState.type}`);
          }
        } else if (status === "not-presenting" || status === "failed" || status === "session-ended") {
          overlayRoot.classList.remove(DOM_OVERLAY_ACTIVE_CLASS);
        }
      }

      // ✅ 수정: AR 버튼 클릭 시 DOM overlay 옵션 설정
      arButton?.addEventListener("click", async (event) => {
        event.preventDefault();
        if (!modelViewer) return;
        if (!modelViewer.canActivateAR) {
          console.warn("현재 환경은 WebXR AR을 지원하지 않습니다.");
          return;
        }

        // ✅ AR 세션 시작 전에 DOM overlay 옵션 설정
        try {
          // model-viewer가 내부적으로 DOM overlay를 처리하도록
          // xr-environment 속성으로 overlay root 지정
          if (overlayRoot && domOverlaySupported) {
            console.log('✅ DOM Overlay 준비:', overlayRoot);
            
            // AR 세션 요청 시 DOM overlay 포함
            const xrSessionInit = {
              requiredFeatures: ['hit-test'],
              optionalFeatures: ['dom-overlay'],
              domOverlay: { root: overlayRoot }
            };

            // model-viewer의 activateAR 메서드 사용
            await modelViewer.activateAR();
          } else {
            await modelViewer.activateAR();
          }
        } catch (error) {
          if (error?.name === "NotSupportedError" || /\bdom[- ]?overlay\b/i.test(error?.message ?? "")) {
            console.error("이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.", error);
            domOverlaySupported = false;
            if (overlayRoot) {
              overlayRoot.classList.remove(DOM_OVERLAY_ACTIVE_CLASS);
            }
            if (arUnsupportedMessage) {
              arUnsupportedMessage.textContent = "이 브라우저는 WebXR DOM Overlay를 지원하지 않습니다.";
              arUnsupportedMessage.style.display = "block";
            }
            arButton?.setAttribute("disabled", "disabled");
            ensureArButtonVisibility();
          } else {
            console.error("AR 세션 진입에 실패했습니다:", error);
          }
        }
      });
    </script>
  </body>
</html>
